#!/usr/bin/env python

#
# ** The MIT License **
#
# Copyright (c) 2013 Andrei Gherzan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

# Home: https://github.com/agherzan/notifmail
#
# Author: Andrei Gherzan <andrei@gherzan.ro>
#

import sys
import imaplib
import notify2
import getpass
import email.Header
import ConfigParser
import os
import urllib2
import getopt
import logging
import signal
from time import sleep

# Global variables which stand as default values
TESTURL             = "http://www.google.com"
APPHOME             = "~/.notifmail"
CONFIGURATIONFILE   = APPHOME + "/notifmail.conf"
LOGFILE             = APPHOME + "/notifmail.log"
MAXLOGSIZE          = 1048576
SECONDS             = 60
LOGLEVEL            = 30

# Logger
log = logging.getLogger()

def Usage():
    """
    Usage function
    """
    print "Usage: notifmail [args]"
    print "     -h | --help         :   Print this message."
    print "     -s | --seconds      :   Specify number of seconds between imap checks. [default=60]"
    print "                         :   Minimum value is 2 seconds."
    print "     -l | --log          :   Log file to be used. [default=~/.notifmail/notifmail.log]"
    print "     -c | --config       :   Config file to be used. [default=~/.notifmail/.notifmailrc]"
    print "     -L | --loglevel     :   Log level to be used while logging. [default=30]"
    print "                         :   Possible values:"
    print "                         :   40 - ERROR"
    print "                         :   30 - WARNING"
    print "                         :   20 - INFO"
    print "                         :   10 - DEBUG"
    print "     -m | --maxlogsize   :   Maximum size in bytes for log file. [default=1048576]"

def sigIntHandler(signum, frame):
    """
    Handler fir signal interrupt
    """
    log.debug("notifmail INTERRUPTED")
    sys.exit(0)

"""
Class for storing an IMAP account
"""
class Imapaccount:
    def __init__ (self, imap_server, imap_user, imap_password):
        """
        Constructor
        """
        self.imap_server = imap_server
        self.imap_user = imap_user
        self.imap_password = imap_password
        self.shownuids = []
        self.mail = None
        self.allnotif = []
        self.summarynotif = []

    def isConnected(self):
        """
        Check if account is connected
        """
        return self.mail

    def Connect(self):
        """
        Connect to sevrer
        """
        log.debug("Connecting to %s.", self.imap_server)
        if not self.mail:
            # Check internet connection
            try:
                ret = urllib2.urlopen(TESTURL,timeout=1)
            except:
                log.warn("Connecting to %s failed. Check your internet connection.", TESTURL)
                return False
            # Connect
            try:
                self.mail = imaplib.IMAP4_SSL(self.imap_server)
            except:
                log.warn("Connecting to %s failed. Check your configuration file.", self.imap_server)
                return False
            # Login
            try:
                (ret, capabilities) = self.mail.login(self.imap_user, self.imap_password)
            except:
                log.warn("Authentification to %s failed. Check your configuration file.", self.imap_server)
                self.Disconnect()
                return False
        log.debug("Connected to %s", self.imap_server)
        return True

    def Disconnect(self):
        """
        Disconnect from server
        """
        log.debug("Disconnecting from %s.", self.imap_server);
        if self.isConnected():
            try :
                self.mail.close()
                self.mail.logout()
            except: pass
            self.mail = None
        else:
            log.warn("Not connected to %s.", self.imap_server)
        return True

    def getMessages(self, mailbox="inbox", flag="UNSEEN"):
        """
        Get messages from mailbox
        """
        log.debug("Get %s messages for %s.", flag, mailbox)
        # We need to make sure we are connected
        if not self.Connect():
            log.warn("Can't get messages because connection to %s failed.", self.imap_server)
            return None
        self.mail.select(mailbox, readonly=1)
        try:
            (ret, messages) = self.mail.uid('search', None, flag)
        except:
            pass
        return [x for x in messages if x]

    def sendIndividualNotifications(self, messages):
        """
        Send a notification for each messages
        """
        for uid in messages[0].split(' '):
            ret, raw_email = self.mail.uid('fetch', uid, '(BODY[HEADER.FIELDS (FROM SUBJECT)])')
            if ret == 'OK':
                if uid not in self.shownuids:
                    email_message = email.message_from_string(raw_email[0][1])
                    # Avoid messing up with markups so remove < and >
                    sender = email_message['From'].translate(None,'<>')
                    subject = email.Header.decode_header(email_message['Subject'])[0][0]
                    notification = notify2.Notification("YOU GOT NEW MAIL", "<b>From:</b> " + sender + "\n<b>Subject:</b> " + subject )
                    notification.set_urgency(notify2.URGENCY_LOW)
                    notification.show()
                    # Mark message shown
                    self.shownuids.append(uid)
                else:
                    log.debug("%s already shown. Skipping notification.", uid)
            else:
                log.warn("Failed to fetch message.")

    def sendSummaryNotification(self):
        """
        Send a summary notification for all messages
        """
        summary = "NEW EMAILS SUMMARY"
        description = ""
        for mailbox in self.summarynotif:
            messages = self.getMessages(mailbox=mailbox)
            if not messages:
                log.info("No messages found in %s.", mailbox)
                continue
            description += "<b>" + mailbox + "</b>" + ": " + str(len(messages[0].split())) + " new messsages.\n"
        if description:
            notification = notify2.Notification(summary, description)
            notification.set_urgency(notify2.URGENCY_LOW)
            notification.show()

    def sendNotifications(self):
        """
        Send Notifications
        """
        log.debug("Sending notification for %s.", self.imap_server)
        for mailbox in self.allnotif:
            messages = self.getMessages(mailbox=mailbox)
            if not messages:
                log.info("No messages found in %s.", mailbox)
                continue
            self.sendIndividualNotifications(messages)

        self.sendSummaryNotification()
        log.debug("Sent notifications for %s.", self.imap_server)
        return True

def ReadConfiguration(conffile):
    """
    Read configuration
    """
    imapaccounts = []
    required = ['imap_server', 'imap_user', 'imap_password']
    config = ConfigParser.ConfigParser()
    try:
        config.read([os.path.expanduser(conffile)])
    except:
        return []

    log.debug("Parsing configuration file %s.", conffile)

    for section in config.sections():
        # Check if account contains all needed options
        if set(required).intersection(set(config.options(section))) == set(required):
            account = Imapaccount(config.get(section, required[0]),
                                  config.get(section, required[1]),
                                  config.get(section, required[2]))
            if config.has_option(section,'all'):
                for folder in config.get(section, 'all').split(';'):
                    account.allnotif.append(folder)
            if config.has_option(section,'summary'):
                for folder in config.get(section, 'summary').split(';'):
                    account.summarynotif.append(folder)
            if not account.allnotif and not account.summarynotif:
                account.allnotif = ['inbox']
            imapaccounts.append(account)
        else:
            log.error("Error: Cannot add account %s. Check your configuration file.")
    return imapaccounts

def main():
    """
    MAIN
    """

    signal.signal(signal.SIGINT, sigIntHandler)

    # Array of accounts
    imapaccounts = []
    seconds = SECONDS
    logfile = LOGFILE
    conffile = CONFIGURATIONFILE
    loglevel = LOGLEVEL
    maxlogsize = MAXLOGSIZE

    # Setting up the logging module
    logformatter = logging.Formatter('%(asctime)s - %(levelname)s : %(message)s')
    log.setLevel(loglevel)

    # Log to console
    ch = logging.StreamHandler()
    ch.setFormatter(logformatter)
    log.addHandler(ch)

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'hs:l:c:L:m:', ['help', 'seconds=', 'log=', 'config=', 'loglevel', 'maxlogsize='])
    except getopt.GetoptError as err:
        print str(err)
        Usage()
        sys.exit(1)

    for option, argument in opts:
        if option in ['-h', '--help']:
            Usage()
            sys.exit(0)
        elif option in ['-s', '--seconds']:
            if int(argument) < 2:
                Usage()
                sys.exit(1)
            else:
                seconds = argument
        elif option in ['-l', '--log']:
            logfile = argument
        elif option in ['-c', '--config']:
            conffile = argument
        elif option in ['-L', '--loglevel']:
            # We are using a log level matching logging module - ERROR, WARNING, INFO and DEBUG
            if argument in ['40', '30', '20', '10']:
                loglevel = int(argument)
                log.setLevel(loglevel)
            else:
                Usage()
                sys.exit(1)
        elif option in ['-m', '--maxlogsize']:
            maxlogsize = int(argument)
        else:
            log.error("Unparsed error.")
            sys.exit(1)

    logfile = os.path.expanduser(logfile)
    logfile = os.path.normpath(logfile)
    conffile = os.path.expanduser(conffile)
    conffile = os.path.normpath(conffile)

    # Make sure APPHOME exists
    if not os.path.isdir(os.path.expanduser(APPHOME)):
        os.makedirs(os.path.expanduser(APPHOME))

    # Log to file
    try:
        fh = logging.FileHandler(logfile)
    except:
        log.error("Can't add file logging to %s.", logfile)
        sys.exit(1)
    fh.setFormatter(logformatter)
    log.addHandler(fh)

    # If logfile if below the maximum logfile size - get rid of it
    if os.path.isfile(logfile) and os.stat(logfile).st_size > maxlogsize:
        log.warn("Logfile %s got over %d bytes. Removing logfile.", logfile, maxlogsize)
        os.remove(logfile)

    log.debug("notifmail STARTED.")

    if not os.path.isfile(conffile):
        log.warn("No such configuration file. Using default.")
        conffile = CONFIGURATIONFILE

    notify2.init("notifmail")

    imapaccounts = ReadConfiguration(conffile)
    if not imapaccounts:
        log.error("Parsing configuration file %s failed or no accounts defined.", conffile)
        sys.exit(1)

    while (True):
        for account in imapaccounts:
            account.sendNotifications()
            account.Disconnect()
        sleep(float(seconds))

if __name__ == "__main__":
    ret = main()
